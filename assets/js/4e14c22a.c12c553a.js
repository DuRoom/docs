"use strict";(self.webpackChunkduroom_docs=self.webpackChunkduroom_docs||[]).push([[9894],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return h}});var i=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function a(e,t){if(null==e)return{};var n,i,s=function(e,t){if(null==e)return{};var n,i,s={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,p=a(e,["components","mdxType","originalType","parentName"]),d=u(n),h=s,m=d["".concat(l,".").concat(h)]||d[h]||c[h]||r;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,o=new Array(r);o[0]=d;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a.mdxType="string"==typeof e?e:s,o[1]=a;for(var u=2;u<r;u++)o[u]=n[u];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1737:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return a},metadata:function(){return u},toc:function(){return c}});var i=n(7462),s=n(3366),r=(n(7294),n(3905)),o=["components"],a={},l="Model Visibility",u={unversionedId:"extend/model-visibility",id:"extend/model-visibility",title:"Model Visibility",description:"This article concerns authorization, and uses some concepts from the authorization system. You should familiarize yourself with that first.",source:"@site/docs/extend/model-visibility.md",sourceDirName:"extend",slug:"/extend/model-visibility",permalink:"/docs/extend/model-visibility",draft:!1,editUrl:"https://github.com/DuRoom/docs/tree/master/docs/extend/model-visibility.md",tags:[],version:"current",frontMatter:{},sidebar:"extendSidebar",previous:{title:"Middleware",permalink:"/docs/extend/middleware"},next:{title:"Model Slugging",permalink:"/docs/extend/slugging"}},p={},c=[{value:"How It&#39;s Processed",id:"how-its-processed",level:2},{value:"Custom Scopers",id:"custom-scopers",level:2},{value:"Where vs orWhere",id:"where-vs-orwhere",level:3},{value:"Custom Scoper Examples",id:"custom-scoper-examples",level:3},{value:"Registering Custom Scopers",id:"registering-custom-scopers",level:3}],d={toc:c};function h(e){var t=e.components,n=(0,s.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"model-visibility"},"Model Visibility"),(0,r.kt)("p",null,"This article concerns authorization, and uses some concepts from the ",(0,r.kt)("a",{parentName:"p",href:"/docs/extend/authorization"},"authorization")," system. You should familiarize yourself with that first."),(0,r.kt)("p",null,"When a user visits the ",(0,r.kt)("strong",{parentName:"p"},"All Discussions")," page, we want to quickly show them the recent discussions that the user has access to.\nWe do this via the ",(0,r.kt)("inlineCode",{parentName:"p"},"whereVisibleTo")," method, which is defined in ",(0,r.kt)("inlineCode",{parentName:"p"},"DuRoom\\Database\\ScopeVisibilityTrait"),", and available to ",(0,r.kt)("a",{parentName:"p",href:"https://laravel.com/docs/8.x/queries"},"Eloquent models and queries")," through ",(0,r.kt)("a",{parentName:"p",href:"https://laravel.com/docs/8.x/eloquent#local-scopes"},"Eloquent scoping"),".\nFor example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"use DuRoom\\Group\\Group;\n\n// Construct and execute a query for all groups that a given user can see.\n$groups = Group::whereVisibleTo($actor)->get();\n\n// Apply visibility scoping to an existing query.\nMore eloquent filters can be added after this.\n$query\n  ->whereVisibleTo($actor)\n  ->whereRaw('1=1');\n\n// Apply visibility scoping with an ability\n$query\n  ->whereVisibleTo($actor, 'someAbility')\n")),(0,r.kt)("p",null,"This is necessary because users shouldn't see all discussions. For instance:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Users shouldn't see discussions in tags they don't have permission to see."),(0,r.kt)("li",{parentName:"ul"},"Users shouldn't see posts in discussions they don't have permission to see."),(0,r.kt)("li",{parentName:"ul"},"Users shouldn't see discussions by other users that haven't been approved yet."),(0,r.kt)("li",{parentName:"ul"},"Users generally shouldn't see hidden discussions.")),(0,r.kt)("p",null,'We accomplish this through a system called "Model Visibility". Essentially, this allows core and extensions to add logic that expands/constrains database queries made by the ',(0,r.kt)("inlineCode",{parentName:"p"},"whereVisibleTo")," method."),(0,r.kt)("p",null,"Please note that visibility scoping can only be used on models that use the ",(0,r.kt)("inlineCode",{parentName:"p"},"DuRoom\\Database\\ScopeVisibilityTrait")," trait."),(0,r.kt)("h2",{id:"how-its-processed"},"How It's Processed"),(0,r.kt)("p",null,"So, what actually happens when we call ",(0,r.kt)("inlineCode",{parentName:"p"},"whereVisibleTo"),'?\nThis call is handled by DuRoom\'s general model visibility scoping system, which runs the query through a sequence of callbacks, which are called "scopers".'),(0,r.kt)("p",null,"The query will be run through all applicable scopers registered for the model of the query. Note that visibility scopers registered for a parent class (like ",(0,r.kt)("inlineCode",{parentName:"p"},"DuRoom\\Post\\Post"),") will also be applied to any child classes (like ",(0,r.kt)("inlineCode",{parentName:"p"},"DuRoom\\Post\\CommentPost"),")."),(0,r.kt)("p",null,"Scopers don't need to return anything, but rather should perform in-place mutations on the ",(0,r.kt)("a",{parentName:"p",href:"https://laravel.com/docs/8.x/queries"},"Eloquent query object"),"."),(0,r.kt)("h2",{id:"custom-scopers"},"Custom Scopers"),(0,r.kt)("p",null,"There are actually two types of scopers:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"ability-based scopers will apply to all queries for the query's model run with a given ability (which defaults to ",(0,r.kt)("inlineCode",{parentName:"li"},'"view"'),"). Please note this is not related to ability strings from the ",(0,r.kt)("a",{parentName:"li",href:"/docs/extend/authorization#how-it-works"},"policy system")),(0,r.kt)("li",{parentName:"ul"},'"global" scopers will apply to all queries for the query\'s model. Please note that global scopers will be run on ALL queries for its model, including ',(0,r.kt)("inlineCode",{parentName:"li"},"view"),", which could create infinite loops or errors. Generally, you only want to run these for abilities that don't begin with ",(0,r.kt)("inlineCode",{parentName:"li"},"view"),". You'll see this in the ",(0,r.kt)("a",{parentName:"li",href:"#custom-visibility-scoper-examples"},"example below"))),(0,r.kt)("p",null,"One common use case for this is allowing extensibility inside visibility scoping.\nLet's take a look at an annotated, simple piece of ",(0,r.kt)("inlineCode",{parentName:"p"},"DuRoom\\Post\\PostPolicy")," as an example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"// Here, we want to ensure that private posts aren't visible to users by default.\n// The simplest way to do this would be:\n$query->where('posts.is_private', false);\n\n// However, we recognize that some extensions might have valid use cases for showing private posts.\n// So instead, we include all posts that aren't private, AND all private posts desired by extensions\n$query->where(function ($query) use ($actor) {\n    $query->where('posts.is_private', false)\n        ->orWhere(function ($query) use ($actor) {\n            $query->whereVisibleTo($actor, 'viewPrivate');\n        });\n});\n")),(0,r.kt)("p",null,"A possible extension further down the line might use something like this to allow some users to some private posts. Note that since\nScopeModelVisibility was dispatched in ",(0,r.kt)("inlineCode",{parentName:"p"},"orWhere"),", these query modifications ONLY apply to ",(0,r.kt)("inlineCode",{parentName:"p"},"$query->where('posts.is_private', false)")," from the example above."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"<?php\n\nuse DuRoom\\User\\User;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nclass ScopePostVisibility\n{\n    public function __invoke(User $actor, $query)\n    {\n      if ($actor->can('posts.viewPrivate')) {\n        $query->whereRaw(\"1=1\");\n      }\n    }\n}\n")),(0,r.kt)("p",null,"Think of calling ",(0,r.kt)("inlineCode",{parentName:"p"},"whereVisibleTo")," with a custom ability as a way for extensions to insert custom code, overriding filters imposed by core (or other extensions)."),(0,r.kt)("h3",{id:"where-vs-orwhere"},"Where vs orWhere"),(0,r.kt)("p",null,"Assume we have a set of discussions, and we want to return a subset of that set based on some restrictions. There are 2 ways to do this:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We could start with the full set of discussions, and remove the ones that shouldn't be in our query. We'd do this via a series of ",(0,r.kt)("inlineCode",{parentName:"li"},"where")," calls: ",(0,r.kt)("inlineCode",{parentName:"li"},"$query->where('is_private', false)"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"$query->where('is_hidden', false)")," etc."),(0,r.kt)("li",{parentName:"ul"},"We could start with an empty set and add the discussions that should be in our query. Here, we'd use ",(0,r.kt)("inlineCode",{parentName:"li"},"orWhere")," calls: ",(0,r.kt)("inlineCode",{parentName:"li"},"$query->orWhere('is_private, false)"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"$query->orWhere('is_hidden, false)"),".")),(0,r.kt)("p",null,"Note that these are not equivalent! The first one would only return discussions that are not private AND not hidden. The second one could return private discussions that are not hidden, as well as hidden discussions that are not private."),(0,r.kt)("p",null,"Generally speaking, we'll want to be consistent with the types of queries we use. Mixing ",(0,r.kt)("inlineCode",{parentName:"p"},"where")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"orWhere")," queries on the same level can lead to unexpected results depending on the order in which queries are applied. Some guidelines:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"For ",(0,r.kt)("inlineCode",{parentName:"li"},"view")," scopers, all logic should be wrapped in a ",(0,r.kt)("inlineCode",{parentName:"li"},"where")," callback query. ",(0,r.kt)("inlineCode",{parentName:"li"},"orWhere")," should NEVER be used on the top level for ",(0,r.kt)("inlineCode",{parentName:"li"},"view"),"."),(0,r.kt)("li",{parentName:"ul"},"For abilities prefixed by ",(0,r.kt)("inlineCode",{parentName:"li"},"view"),", (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"viewPrivate"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"viewHidden"),"), and similar calls, all logic should be wrapped in an ",(0,r.kt)("inlineCode",{parentName:"li"},"orWhere")," callback query.")),(0,r.kt)("p",null,"For abilities that don't start with ",(0,r.kt)("inlineCode",{parentName:"p"},"view"),", it will depend case-by-case. As a general rule:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"whereVisibleTo($actor, 'someAbilityName')")," is called from regular code (e.g. ",(0,r.kt)("inlineCode",{parentName:"li"},"Discussion::query()->whereVisibleTo($actor, 'someAbilityName')"),"), scopers for ",(0,r.kt)("inlineCode",{parentName:"li"},"someAbilityName")," should wrap their logic in a ",(0,r.kt)("inlineCode",{parentName:"li"},"where"),"."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"whereVisibleTo($actor, 'someAbilityName')")," is called from another visibility scoper, scopers for ",(0,r.kt)("inlineCode",{parentName:"li"},"someAbilityName")," should wrap their logic in an ",(0,r.kt)("inlineCode",{parentName:"li"},"orWhere"),".")),(0,r.kt)("p",null,"This is because top-level scoper logic should constrain the query down, but each of those constraints might have exceptions, for which we'd want to add instances back in. For example, users should see discussions if:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The discussion is not private",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Or they are the author."),(0,r.kt)("li",{parentName:"ul"},"Or the discussion needs approval and the current user can approve discussions."))),(0,r.kt)("li",{parentName:"ul"},"The discusion is not hidden",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"Or they are the author."),(0,r.kt)("li",{parentName:"ul"},"Or they are an admin.")))),(0,r.kt)("p",null,"See how the top-level statements are the equivalent of ",(0,r.kt)("inlineCode",{parentName:"p"},"where"),"s, but their sub-statements are ",(0,r.kt)("inlineCode",{parentName:"p"},"orWhere"),"s that add exceptions to those general rules?"),(0,r.kt)("h3",{id:"custom-scoper-examples"},"Custom Scoper Examples"),(0,r.kt)("p",null,"Let's take a look at some examples from ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/DuRoom/tags/blob/master/src/Access"},"DuRoom Tags"),"."),(0,r.kt)("p",null,"First, a scoper for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Tag")," model with the ",(0,r.kt)("inlineCode",{parentName:"p"},"view")," ability:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"<?php\n\nnamespace DuRoom\\Tags\\Access;\n\nuse DuRoom\\Tags\\Tag;\nuse DuRoom\\User\\User;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nclass ScopeTagVisibility\n{\n    /**\n     * @param User $actor\n     * @param Builder $query\n     */\n    public function __invoke(User $actor, Builder $query)\n    {\n        $query->whereIn('id', function ($query) use ($actor) {\n            Tag::query()->setQuery($query->from('tags'))->whereHasPermission($actor, 'viewForum')->select('tags.id');\n        });\n    }\n}\n")),(0,r.kt)("p",null,"And a global scoper for the ",(0,r.kt)("inlineCode",{parentName:"p"},"Discussion")," model:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"<?php\n\nnamespace DuRoom\\Tags\\Access;\n\nuse DuRoom\\Tags\\Tag;\nuse DuRoom\\User\\User;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nclass ScopeDiscussionVisibilityForAbility\n{\n    /**\n     * @param User $actor\n     * @param Builder $query\n     * @param string $ability\n     */\n    public function __invoke(User $actor, Builder $query, $ability)\n    {\n        // Automatic scoping should be applied to the global `view` ability,\n        // and to arbitrary abilities that aren't subqueries of `view`.\n        // For example, if we want to scope discussions where the user can\n        // edit posts, this should apply.\n        // But if we are expanding a restriction of `view` (for example,\n        // `viewPrivate`), we shouldn't apply this query again.\n        if (substr($ability, 0, 4) === 'view' && $ability !== 'view') {\n            return;\n        }\n\n        // Avoid an infinite recursive loop.\n        if (Str::endsWith($ability, 'InRestrictedTags')) {\n            return;\n        }\n\n        // `view` is a special case where the permission string is represented by `viewForum`.\n        $permission = $ability === 'view' ? 'viewForum' : $ability;\n\n        // Restrict discussions where users don't have necessary permissions in all tags.\n        // We use a double notIn instead of a doubleIn because the permission must be present in ALL tags,\n        // not just one.\n        $query->where(function ($query) use ($actor, $permission) {\n            $query\n                ->whereNotIn('discussions.id', function ($query) use ($actor, $permission) {\n                    return $query->select('discussion_id')\n                        ->from('discussion_tag')\n                        ->whereNotIn('tag_id', function ($query) use ($actor, $permission) {\n                            Tag::query()->setQuery($query->from('tags'))->whereHasPermission($actor, $permission)->select('tags.id');\n                        });\n                })\n                ->orWhere(function ($query) use ($actor, $permission) {\n                    // Allow extensions a way to override scoping for any given permission.\n                    $query->whereVisibleTo($actor, \"${permission}InRestrictedTags\");\n                });\n        });\n\n        // Hide discussions with no tags if the user doesn't have that global\n        // permission.\n        if (! $actor->hasPermission($permission)) {\n            $query->has('tags');\n        }\n    }\n}\n")),(0,r.kt)("p",null,"Note that, as mentioned above, we don't run this for abilities starting with ",(0,r.kt)("inlineCode",{parentName:"p"},"view"),", since those are handled by their own, dedicated scopers."),(0,r.kt)("p",null,"And finally, a scoper for the ",(0,r.kt)("inlineCode",{parentName:"p"},"viewPrivate")," ability (this one is a fake example, not from tags):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"<?php\n\nnamespace ACME\\YourExtension\\Access;\n\nuse DuRoom\\Discussion\\Discussion;\nuse DuRoom\\User\\User;\nuse Illuminate\\Database\\Eloquent\\Builder;\n\nclass ScopeDiscussionVisibility\n{\n    /**\n     * @param User $actor\n     * @param Builder $query\n     */\n    public function __invoke(User $actor, Builder $query)\n    {\n        $query->orWhere(function($query) use ($actor) {\n            $query->where('some_column', true);\n            $query->where('some_other_column', false);\n        })\n    }\n}\n")),(0,r.kt)("p",null,"Note that in contrast to the other 2 examples, we're using ",(0,r.kt)("inlineCode",{parentName:"p"},"orWhere")," to wrap our logic. This is explained ",(0,r.kt)("a",{parentName:"p",href:"#where-vs-orwhere"},"above")),(0,r.kt)("h3",{id:"registering-custom-scopers"},"Registering Custom Scopers"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-php"},"use DuRoom\\Extend;\nuse DuRoom\\Discussion\\Discussion;\nuse DuRoom\\Tags\\Tag;\nuse YourNamespace\\Access;\n\nreturn [\n  // Other extenders\n\n  // 'view' is optional here, since that's the default value for the ability argument.\n  // However, if we were applying this to a different ability, such as `viewPrivate`,\n  // would need to explicitly specify that.\n  (new Extend\\ModelVisibility(Tag::class))\n    ->scope(Access\\ScopeTagVisibility::class, 'view'),\n\n  (new Extend\\ModelVisibility(Discussion::class))\n    ->scopeAll(Access\\ScopeDiscussionVisibilityForAbility::class),\n  // Other extenders\n];\n")))}h.isMDXComponent=!0}}]);